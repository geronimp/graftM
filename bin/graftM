#!/usr/bin/env python

##### ##### ##### ##### ##### ##### #####
#                                       #
#                 graftM                #
#                                       #
#  A pipeline for gene centric analyses #
#          of metagenome datasets       #
#                                       #
##### ##### ##### ##### ##### ##### #####

__author__ = "Joel Boyd, Ben Woodcroft"
__copyright__ = "Copyright 2014"
__credits__ = ["Joel Boyd", "Ben Woodcroft"]
__license__ = "GPL3"
__maintainer__ = "Joel Boyd, Ben Woodcroft"
__email__ = "joel.boyd near uq.net.au, b.woodcroft near uq.edu.au"
__status__ = "Development"

import argparse
import sys
import os
import logging

sys.path = [os.path.join(os.path.dirname(os.path.realpath(__file__)),'..')]+sys.path
import graftm
from graftm.run import Run


class CustomHelpFormatter(argparse.HelpFormatter):
    def _split_lines(self, text, width):
        return text.splitlines()

    def _get_help_string(self, action):
        h = action.help
        if '%(default)' not in action.help:
            if action.default != '' and \
               action.default != [] and \
               action.default != None \
               and action.default != False:
                if action.default is not argparse.SUPPRESS:
                    defaulting_nargs = [argparse.OPTIONAL,
                                        argparse.ZERO_OR_MORE]

                    if action.option_strings or action.nargs in defaulting_nargs:

                        if '\n' in h:
                            lines = h.splitlines()
                            lines[0] += ' (default: %(default)s)'
                            h = '\n'.join(lines)
                        else:
                            h += ' (default: %(default)s)'
        return h

    def _fill_text(self, text, width, indent):
        return ''.join([indent + line for line in text.splitlines(True)])

def phelp():
    print """
                                       GraftM  %s

             A suite of tools for the rapid analysis of metagenome sequence datasets.

                                Joel Boyd, Ben Woodcroft

=====================================================================================================
COMMUNITY PROFILING

    graft       -       Search for and phylogenetically classify reads associated with a single
                        marker gene, and construct a community profile
                        See graftM graft -h
                        
                        Example usage:
                            $ graftM graft --forward <READS> --graftm_package <GRAFTM_PACKAGE>

=====================================================================================================
UTILITIES

    create      -       Create a graftM packages from sequence alignments and classifications. 
                        See graftM create -h
                        
    bootstrap   -       Create new HMMs from a base HMM and an assembly or genome. 
                        See graftM bootstrap -h
    
    decorate    -       Decorate a tree with provided taxonomy, and attempt to re-root the tree
                        (if needed) using a reference rooted tree.
                        See graftM decorate -h

=====================================================================================================
""" % (graftm.__version__)

def print_header():
    print """                         
                             GraftM %s""" %(graftm.__version__)

debug={1:logging.CRITICAL,
       2:logging.ERROR,
       3:logging.WARNING,
       4:logging.INFO,
       5:logging.DEBUG}

if __name__ == '__main__':
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--version', action='version', version='graftM v%s' % graftm.__version__)
    subparsers = parser.add_subparsers(help="--", dest='subparser_name')
    
    
    ########################################################################
    # Graft pipeline - Create phylogeentically informed community profiles #
    ########################################################################
    graft_parser = subparsers.add_parser('graft',
                                        description='Search and classify marker genes to construct community profiles',
                                        epilog=__author__)
    input_options = graft_parser.add_argument_group('input options')
    input_options.add_argument('--forward', nargs='+', metavar='forward_read', help='Forward read (or single read file), space separated in .fa, or .fq.gz format.', required=True)
    input_options.add_argument('--reverse', nargs='+',metavar='reverse read', help='[do NOT use unless you understand the difficulties with this] Optional reverse raw sequence file(s) in .fa, or .fq.gz format', default=None)
    input_options.add_argument('--graftm_package', metavar='reference_package', help='Reference package of gene family')

    running_options = graft_parser.add_argument_group('running options')
    running_options.add_argument('--threads', type=int, metavar='threads', help='Number of threads to use (default = 5)', default=5)
    running_options.add_argument('--input_sequence_type', help='Specify whether the input sequence is "nucleotide" or "aminoacid" sequence data (default=will attempt to auto-detect)', choices = ['aminoacid', 'nucleotide'],  default=argparse.SUPPRESS)
    
    searching_options = graft_parser.add_argument_group('searching options')
    searching_options.add_argument('--evalue', metavar='evalue', help='evalue cutoff for the hmmsearch (default = 1e-5)', default= '1e-5')
    searching_options.add_argument('--search_and_align_only', action="store_true", help='Stop after reads have been identified (default=False)', default=False)
    searching_options.add_argument('--euk_check', action="store_true", help='Search whole sample for 18S (default=False)', default=False)
    searching_options.add_argument('--search_method', choices=('hmmsearch','diamond'), help='Search method (default=hmmsearch)', default='hmmsearch')
    searching_options.add_argument('--maximum_range', type=int, help='maximum range to use when searching for potentially linked reads (when searching contigs)', default=None)
    searching_options.add_argument('--bootstrap_contigs', nargs='+', help='generate an HMM for searching --forward data by first searching these contigs')
    
    placement_options = graft_parser.add_argument_group('taxonomic assignment options')
    placement_options.add_argument('--assignment_method', help='Taxonomic assignment method used (default=pplacer)', default=Run.PPLACER_TAXONOMIC_ASSIGNMENT, choices=(Run.PPLACER_TAXONOMIC_ASSIGNMENT,Run.DIAMOND_TAXONOMIC_ASSIGNMENT))
    
    pplacer_options = graft_parser.add_argument_group('pplacer assignment options')
    pplacer_options.add_argument('--placements_cutoff', metavar='confidence', help='Cutoff of placement confidence level (0.5 - 1), default=0.75', default=0.75)
    pplacer_options.add_argument('--resolve_placements', action="store_true", help='Force taxonomy down to the best placement (default=False)', default=False)
    pplacer_options.add_argument('--merge_reads', action="store_true", help='Merge forward and reverse read alignments for placement (default=False)', default=False)
    pplacer_options.add_argument('--no_clustering', action="store_true", help='Cluster reads at 100%% before placement to reduce tree insertion time -- ONLY use with unassembled data (i.e. equal read length). Default = False.', default=False)

    nucleotide_options = graft_parser.add_argument_group('nucleotide search-specific options')
    nucleotide_options.add_argument('--search_hmm_files', nargs='+', help='Specify .hmm files to use in search step', default=argparse.SUPPRESS)
    nucleotide_options.add_argument('--search_hmm_list_file', metavar='newline-separated file with paths to each search HMM', default=argparse.SUPPRESS)
    nucleotide_options.add_argument('--search_diamond_file', nargs=1, help='Specify .dmnd file to use in search step', default=None)
    nucleotide_options.add_argument('--aln_hmm_file', help='Specify a single .hmm file to use in align step (default: the search_hmm_file if there is only 1)', default=argparse.SUPPRESS)
    nucleotide_options.add_argument('--euk_hmm_file', help='Specify the .hmm file to use in the check for euk contamination', default=argparse.SUPPRESS)
    
    protein_options = graft_parser.add_argument_group('protein search-specific options')
    min_orf_length_default = 96
    protein_options.add_argument('--min_orf_length', metavar='length', help='Minimum number of nucleotides in an open reading frame (default: %s)' % min_orf_length_default, default=min_orf_length_default, type=int)
    protein_options.add_argument('--restrict_read_length', metavar='length', help='Only use this many base pairs at the start of each sequence searched (default: no restriction)', type=int)
    
    logging_options = graft_parser.add_argument_group('logging options')
    logging_options.add_argument('--verbosity', metavar='verbosity', help='1 - 5, 1 being silent, 5 being noisy indeed. Default = 4', type=int, default=4)
    logging_options.add_argument('--log', metavar='logfile', help='Output logging information to file', default=False)
    
    output_options = graft_parser.add_argument_group('output options')
    output_options.add_argument('--output_directory', metavar='reference_package', help='Output directory name (default=\"GraftM_output\")', default="GraftM_output")
    output_options.add_argument('--force', action="store_true", help='Force overwrite the output directory, even if one already exists with the same name (default=False)', default=False)


    #############################################################
    # Create - Create a gpkg from a sequence database and a hmm #
    #############################################################
    create_parser = subparsers.add_parser('create',
                                            description='Create a graftM packages from sequence alignments and classifications',
                                            formatter_class=CustomHelpFormatter,
                                            epilog='''Example usage:

 With an alignment of sequences, and a taxonomy file specifying the taxonomy of
 each:
  $ graftM create --alignment my_alignment.fasta --taxonomy my_taxonomy.tsv --sequences my_sequences.fasta
  
 The taxonomy file is a 2 column tab separated file, where the first column
 is the sequence identifier and the second a taxonomy string describing that
 sequence e.g.
 
sequence1    k__kingdom1; p__phylum2

 Internally, the taxonomic levels separated by '; ' are assumed to be kingdom,
 phylum, class, order, family, genus, species. However, this may not matter
 for the purposes of using graftM. The prefixes e.g. 'k__' are not required.
''')

    create = create_parser.add_argument_group('Common options')
    create.add_argument('--taxonomy', metavar='TAX', help='File containing two tab separated columns, the first with the ID of the sequences, the second with the taxonomy string (required unless --rerooted_annotated_tree or --taxtastic_taxonomy and --taxtastic_seqinfo are specified)')
    create.add_argument('--alignment', metavar='ALN', help='An alignment with which to build a custom HMM and tree (required unless --hmm is set)')
    create.add_argument('--sequences', metavar='FASTA', help='Unaligned sequences (required)', required=True)
    create.add_argument('--rerooted_tree', help='A tree with which to build the refpkg, appropriately rooted. (default: generate tree with FastTree and attempt reroot with taxtastic)')
    
    create_lesser_options=create_parser.add_argument_group('Lesser used options')
    create_lesser_options.add_argument('--rerooted_annotated_tree', metavar='newick_tree', help='Define taxonomy through this annotated newick file. (default: use taxonomy from --taxonomy)')
    create_lesser_options.add_argument('--hmm', metavar='.hmm file', help='Use this HMM for alignment, and search unless --search_hmm_files is specified. (default: use HMM built automatically from alignment)')
    create_lesser_options.add_argument('--search_hmm_files', metavar='.hmm files', nargs='+', help='Use these HMM(s) for search. (default: use --hmm or build automatically from alignment)')
    create_lesser_options.add_argument('--min_aligned_percent', type=int, metavar='percent', help='Remove sequences from the alignment which do not cover at least this percentage of the HMM', default=50)
    create_lesser_options.add_argument('--output', metavar='PATH', help='Name of output GraftM package (default: use name derived from alignment)')
    create_lesser_options.add_argument('--tree_log', help='A log file for the tree. (default: generate from tree and alignment)')
    create_lesser_options.add_argument('--taxtastic_taxonomy', help='A taxtastic format taxonomy file. (default: use taxonomy from --taxonomy)')
    create_lesser_options.add_argument('--taxtastic_seqinfo', help='A taxtastic format seqinfo file. (default: use taxonomy from --taxonomy)')
    create_lesser_options.add_argument('--force', action="store_true", help='Overwrite output gpkg directory if it exists. (default: be cowardly and don\'t)', default=False)
    
    create_logging_options=create_parser.add_argument_group('Logging options')
    create_logging_options.add_argument('--verbosity', metavar='verbosity', help='1 - 5, 1 being silent, 5 being noisy indeed', type=int, default=4)
    create_logging_options.add_argument('--log', metavar='logfile', help='output logging information to file', default=False)

    
    #########################################################################
    # Bootstrap                                                             #
    #########################################################################    
    bootstrap_parser = subparsers.add_parser('bootstrap',
                                            description='Generate a new HMM/database from the given contigs',
                                            epilog=__author__)
    bootstrap_parser.add_argument('--contigs', nargs='+', help='contigs to search', required=True)
    bootstrap_parser.add_argument('--output_hmm', help='output HMM file', required=True)
    bootstrap_parser.add_argument('--graftm_package', help='find sequences with this graftm package')
    bootstrap_parser.add_argument('--search_hmm_files', nargs='+', help='find sequences with this/these HMM(s)')
    bootstrap_parser.add_argument('--maximum_range', type=int, help='maximum range to use when searching for potentially linked reads when searching contigs (default: from graftm_package or else 1000)', default=1000)
    bootstrap_parser.add_argument('--evalue', help='evalue cutoff for the hmmsearch (default = 1e-5)', default= '1e-5')
    bootstrap_parser.add_argument('--min_orf_length', help='Minimum number of nucleotides in an open reading frame (default: %s)' % min_orf_length_default, default=min_orf_length_default, type=int)
    bootstrap_parser.add_argument('--threads', type=int, metavar='threads', help='Number of threads to use (default = 5)', default=5)
    
    logging_options = bootstrap_parser.add_argument_group('logging options')
    logging_options.add_argument('--verbosity', metavar='verbosity', help='1 - 5, 1 being silent, 5 being noisy indeed. Default = 4', type=int, default=4)
    logging_options.add_argument('--log', metavar='logfile', help='Output logging information to file', default=False)    
    
    #########################################################################
    # argparser for "decorate" - Reroot, and decorate a gene tree                           
  
    decorate_parser = subparsers.add_parser('decorate',
                                            description='Reroot, and decorate a gene tree',
                                            formatter_class=CustomHelpFormatter,
                                            epilog='''Example usage:

Decorate input.tre with my.taxonomy, and output the decorated tree to output.tre and taxonomy to output.taxonomy:

$ graftM decorate --rooted_tree input.tre --taxonomy my.taxonomy --output_tree output.tre --output_taxonomy output.taxonomy

'''+__author__)    
    tree_options = decorate_parser.add_argument_group('tree options')
    tree_options.add_argument('--rooted_tree', help='Path to rooted tree in newick format. GraftM will decorate this tree under the \
assumption it is correctly rooted.')
    tree_options.add_argument('--unrooted_tree', help='Path to unrooted tree in newick format. GraftM decorate will first attempt to \
reroot using the --reference_tree. Once rerooted, GraftM will decorate this tree.')
    tree_options.add_argument('--reference_tree', help='Path to tree that is rooted correctly that will be used to reroot the \
tree provided to the --unrooted_tree flag (required).')
    tree_options.add_argument('--output_tree', help='Output decorated tree', required=True)
    
    decorate_options = decorate_parser.add_argument_group('taxonomy options')
    decorate_options.add_argument('--input_greengenes_taxonomy', help='Input taxonomy of sequences used to build tree. This taxonomy \
must be in GreenGenes format (2 column tab separated, ID then taxonomy with taxonomy separated by \'; \'. Prefixes such as \'p__\' are not required')
    decorate_options.add_argument('--input_taxtastic_taxonomy', help='Input taxonomy of sequences used to build tree. This taxonomy \
must be in taxtastic format.')
    decorate_options.add_argument('--input_taxtastic_seqinfo', help='Seqinfo file to accompany Taxtastic taxonomy file')
    decorate_options.add_argument('--output_taxonomy', help='File path to output decorated taxonomy strings in GreenGenes format \
corresponding to each leaf in the tree.', required=True)

    # Logging options                                        
    logging_options = decorate_parser.add_argument_group('logging options')
    logging_options.add_argument('--verbosity', metavar='verbosity', help='1 - 5, 1 being silent, 5 being noisy indeed. Default = 4', type=int, default=4)
    logging_options.add_argument('--log', metavar='logfile', help='Output logging information to file', default=False)
    #########################################################################    
                     
    if(len(sys.argv) == 1 or sys.argv[1] == '-h' or sys.argv[1] == '--help'):
        phelp()
    else:
        args = parser.parse_args()
        if args.verbosity >=3: print_header()
        if args.log:
            if os.path.isfile(args.log): raise Exception("File %s exists" % args.log)
            logging.basicConfig(filename=args.log, level=debug[args.verbosity], format='%(asctime)s %(levelname)s: %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
        else:
            logging.basicConfig(level=debug[args.verbosity], format='%(asctime)s %(levelname)s: %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
        
        logging.debug("Ran command: %s" % ' '.join(sys.argv))
        
        Run(args).main()



